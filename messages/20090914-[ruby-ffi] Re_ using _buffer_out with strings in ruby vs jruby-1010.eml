Delivered-To: headius@headius.com
Received: by 10.224.67.198 with SMTP id s6cs289494qai;
        Mon, 14 Sep 2009 17:22:57 -0700 (PDT)
Received: by 10.114.30.7 with SMTP id d7mr12541546wad.30.1252974176314;
        Mon, 14 Sep 2009 17:22:56 -0700 (PDT)
Return-Path: <grbounce-oS_-awUAAACicsVXPUFstTOYQmrUJNfw=headius=headius.com@googlegroups.com>
Received: from mail-pz0-f168.google.com (mail-pz0-f168.google.com [209.85.222.168])
        by mx.google.com with ESMTP id 9si6887333pzk.28.2009.09.14.17.22.55;
        Mon, 14 Sep 2009 17:22:55 -0700 (PDT)
Received-SPF: pass (google.com: domain of grbounce-oS_-awUAAACicsVXPUFstTOYQmrUJNfw=headius=headius.com@googlegroups.com designates 209.85.222.168 as permitted sender) client-ip=209.85.222.168;
Authentication-Results: mx.google.com; spf=pass (google.com: domain of grbounce-oS_-awUAAACicsVXPUFstTOYQmrUJNfw=headius=headius.com@googlegroups.com designates 209.85.222.168 as permitted sender) smtp.mail=grbounce-oS_-awUAAACicsVXPUFstTOYQmrUJNfw=headius=headius.com@googlegroups.com; dkim=pass (test mode) header.i=@googlegroups.com
Received: by pzk40 with SMTP id 40so1623207pzk.7
        for <headius@headius.com>; Mon, 14 Sep 2009 17:22:54 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=googlegroups.com; s=beta;
        h=domainkey-signature:received:received:x-sender:x-apparently-to
         :received:received:received:received-spf:received:dkim-signature
         :domainkey-signature:mime-version:received:in-reply-to:references
         :date:message-id:subject:from:to:content-type
         :content-transfer-encoding:reply-to:sender:precedence:x-google-loop
         :mailing-list:list-id:list-post:list-help:list-unsubscribe
         :x-beenthere-env:x-beenthere;
        bh=LidQDI5TgDK9XAUancldMaNoenEWfH58fc92THGPdZo=;
        b=G3gWdQStgsvALDi7Lj7J7uiMN4u0bFMM0c2++2Hmjy34YU6z2hOKhrnhtXoK7K4aA5
         vK3u3wBV8hOXcb3IpzNG54FonJkIW+N4BujxzZLnXgAuODuMmgYzVAI4zye5K5IJmKjD
         1duFjVFy2jOc+JuXrqiTjB+zkka3LldzUN8II=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=googlegroups.com; s=beta;
        h=x-sender:x-apparently-to:received-spf:authentication-results
         :dkim-signature:domainkey-signature:mime-version:in-reply-to
         :references:date:message-id:subject:from:to:content-type
         :content-transfer-encoding:reply-to:sender:precedence:x-google-loop
         :mailing-list:list-id:list-post:list-help:list-unsubscribe
         :x-beenthere-env:x-beenthere;
        b=kxIevbqiW7vO2zk2HtnfdZUGeBY2kxWdappxlTnS2SJ4KBmaKQNhNySjSBFUao19yn
         GvEBU1efh2jsGVkRT/xuJN/vmHuGY0OxygWq3ORD3NJHHv1bi1nBmO8bEsf7gQfE795W
         cFE7eKz3n4fgnQEOF/v2Ijw87KNT5LeimHoBc=
Received: by 10.140.171.14 with SMTP id t14mr463186rve.22.1252973672399;
        Mon, 14 Sep 2009 17:14:32 -0700 (PDT)
Received: by 10.107.101.15 with SMTP id d15gr26prm.0;
	Mon, 14 Sep 2009 17:14:32 -0700 (PDT)
X-Sender: themastermind1@gmail.com
X-Apparently-To: ruby-ffi@googlegroups.com
Received: by 10.150.235.20 with SMTP id i20mr3827292ybh.16.1252973671431; Mon, 14 Sep 2009 17:14:31 -0700 (PDT)
Received: by 10.150.235.20 with SMTP id i20mr3827291ybh.16.1252973671413; Mon, 14 Sep 2009 17:14:31 -0700 (PDT)
Return-Path: <themastermind1@gmail.com>
Received: from mail-yx0-f177.google.com (mail-yx0-f177.google.com [209.85.210.177]) by gmr-mx.google.com with ESMTP id 18si577825yxe.0.2009.09.14.17.14.30; Mon, 14 Sep 2009 17:14:30 -0700 (PDT)
Received-SPF: pass (google.com: domain of themastermind1@gmail.com designates 209.85.210.177 as permitted sender) client-ip=209.85.210.177;
Received: by mail-yx0-f177.google.com with SMTP id 7so4703045yxe.25 for <ruby-ffi@googlegroups.com>; Mon, 14 Sep 2009 17:14:30 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=gamma; h=domainkey-signature:mime-version:received:in-reply-to:references :date:message-id:subject:from:to:content-type :content-transfer-encoding; bh=mvEzB8frIqWUDg4xIjdTmFar04QkxaCYKVFmZueZzok=; b=H0Bg0tAWt/fsrUtY3KEvv2Gr2Gr2s2R0Mjc+5Vf3m2JGvJRkqRSoNmfro19se6iOdC edHcQUP0jDzF2SaWW6nqoD05T+veYRo2btEnsKf8kd8CPiTBvzIHrzZuglMt1AL2qTHA oO6BumVV0VjeXJ3HxoBTyXDaWDMhahjhg+ajU=
DomainKey-Signature: a=rsa-sha1; c=nofws; d=gmail.com; s=gamma; h=mime-version:in-reply-to:references:date:message-id:subject:from:to :content-type:content-transfer-encoding; b=PKKrhvXWuLCNJRIN2RYUBJVqAo94BPdxKxU0vYyg9jTz3utKMc12o+jk+x8fcyY0rO 9/W9mNk7f4kWRI6xA9jbY9gGUJqOx9cnIE7HP8euyq07DYXqUBZ/T4gePAJlGHkhsTAs HYk40BA8IjCEmxj6mFYzKu1ZtLv+K6Ze3d35A=
MIME-Version: 1.0
Received: by 10.150.170.2 with SMTP id s2mr11259049ybe.222.1252973670127; Mon,  14 Sep 2009 17:14:30 -0700 (PDT)
In-Reply-To: <4ccee320909141700l5b64c0eam95522f25afd7928f@mail.gmail.com>
References: <531031b1-b784-4180-b341-3ab5cf6eaf7a@f20g2000prn.googlegroups.com> <4ccee320909140725s73a1eef1sf44ed87743afa2d0@mail.gmail.com> <e1c05edd0909141223s7abdd2e7u96374449969b9fd7@mail.gmail.com> <4ccee320909141700l5b64c0eam95522f25afd7928f@mail.gmail.com>
Date: Mon, 14 Sep 2009 17:14:30 -0700
Message-ID: <e1c05edd0909141714l396c95d8x82223917b67f5690@mail.gmail.com>
Subject: [ruby-ffi] Re: using :buffer_out with strings in ruby vs jruby
From: Aman Gupta <themastermind1@gmail.com>
To: ruby-ffi@googlegroups.com
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: quoted-printable
Reply-To: ruby-ffi@googlegroups.com
Sender: ruby-ffi@googlegroups.com
Precedence: bulk
X-Google-Loop: groups
Mailing-List: list ruby-ffi@googlegroups.com;
	contact ruby-ffi+owner@googlegroups.com
List-Id: <ruby-ffi.googlegroups.com>
List-Post: <mailto:ruby-ffi@googlegroups.com>
List-Help: <mailto:ruby-ffi+help@googlegroups.com>
List-Unsubscribe: <http://googlegroups.com/group/ruby-ffi/subscribe>,
	<mailto:ruby-ffi+unsubscribe@googlegroups.com>
X-BeenThere-Env: ruby-ffi@googlegroups.com
X-BeenThere: ruby-ffi@googlegroups.com


Cool, thanks for the clarification.

In my case I need to pass some data to a C library, but give up
control of the associated memory, since the C lib will eventually call
free() on it. Seems like the best way to do this is to allocate the
memory using g_memdup(:buffer_in), and use that pointer in the call to
the C lib that needs it.

  Aman

On Mon, Sep 14, 2009 at 5:00 PM, Wayne Meissner <wmeissner@gmail.com> wrote=
:
>
> They're actually handled in the same way.
>
> Both Buffer and string in JRuby are backed by a java byte[] array, and
> to pass that to a native function, a temporary memory area is
> allocated, the contents are copied in to the native memory, then the
> temporary native memory is passed to the function. =A0After the function
> call, the native memory is copied back to the byte[] array (if
> requested), and the native memory is freed before returning back to
> java/ruby.
>
> Thats pretty much the difference between Buffer and MemoryPointer.
> With MemoryPointer, you are allocating the native memory immediately
> when you create the MemoryPointer, and it gets freed when
> MemoryPointer gets garbage collected. =A0You get complete control over
> the memory life cycle, so you can pass a MemoryPointer in to a
> function that will keep a reference to the address.
>
> With Buffer, the native memory is considered to be transient - this
> allows the implementation (like JRuby) to optimize when/how native
> memory is actually allocated/released for it, which can make a huge
> difference (10x or more) when used as e.g. passing an int
> by-reference.
>
> 2009/9/15 Aman Gupta <themastermind1@gmail.com>:
>>
>> Thanks, changing it to :buffer_in works as expected.
>>
>> When I create an explicit Buffer and pass it in using :pointer, the
>> memory allocated for that buffer is freed when the ruby object is
>> garbage collected. What happens when I pass in a string as :buffer_in
>> instead? The contents of the string are copied into a temporary
>> buffer, but when is the buffer freed? or does it live on the stack?
>>
>> =A0Aman
>>
>> On Mon, Sep 14, 2009 at 7:25 AM, Wayne Meissner <wmeissner@gmail.com> wr=
ote:
>>>
>>> If that code is doing what I think it is doing, you have the direction =
wrong.
>>>
>>> :buffer_out =3D=3D copy out from native memory to ruby memory
>>> :buffer_in =3D=3D copy in to native memory from ruby memory
>>>
>>> Think of them like IN and OUT parameter specifications. =A0IN means the
>>> data is passed IN to the function, OUT means the function can alter
>>> the value of the parameter. =A0INOUT means both.
>>>
>>> As to why the tests fail if you pass the string first, its because the
>>> string gets overwritten with garbage from native memory due to the OUT
>>> param spec.
>>>
>>> The tests work with :pointer, because it is basically the same as
>>> :buffer_inout when it comes to string and Buffer arguments - the data
>>> is first copied IN to native memory from ruby, then after the call,
>>> the native data is copied OUT from native memory to ruby, =A0overwritin=
g
>>> the data with the same thing as was already there.
>>>
>>> 2009/9/14 Aman Gupta <themastermind1@gmail.com>:
>>>>
>>>> I'm seeing different behavior on ruby vs jruby when passing in a
>>>> string as a :buffer_out argument:
>>>>
>>>> require 'rubygems'
>>>> require 'ffi'
>>>>
>>>> module GLib
>>>> =A0extend FFI::Library
>>>> =A0ffi_lib 'libglib-2.0'
>>>> =A0attach_function :g_memdup_buf, :g_memdup,
>>>> [ :buffer_out, :uint ], :pointer
>>>> =A0attach_function :g_memdup_ptr, :g_memdup,
>>>> [ :pointer, :uint ], :pointer
>>>>
>>>> =A0def self.test_memdup(arg_type, func_type)
>>>> =A0 =A0ostr =3D "a\0b\0c"
>>>>
>>>> =A0 =A0if arg_type =3D=3D :string
>>>> =A0 =A0 =A0arg =3D ostr.dup
>>>> =A0 =A0elsif arg_type =3D=3D :buffer
>>>> =A0 =A0 =A0arg =3D FFI::Buffer.new(ostr.size)
>>>> =A0 =A0 =A0arg.put_bytes(0, ostr)
>>>> =A0 =A0end
>>>>
>>>> =A0 =A0if func_type =3D=3D :buffer_out
>>>> =A0 =A0 =A0ret =3D GLib.g_memdup_buf(arg, arg.size)
>>>> =A0 =A0elsif func_type =3D=3D :pointer
>>>> =A0 =A0 =A0ret =3D GLib.g_memdup_ptr(arg, arg.size)
>>>> =A0 =A0end
>>>>
>>>> =A0 =A0rstr =3D ret.get_bytes(0, ostr.size)
>>>>
>>>> =A0 =A0p [arg_type, func_type, ostr, rstr, ostr =3D=3D rstr]
>>>> =A0end
>>>> end
>>>>
>>>> GLib.test_memdup(:buffer, :buffer_out)
>>>> GLib.test_memdup(:buffer, :pointer)
>>>> GLib.test_memdup(:string, :buffer_out)
>>>> GLib.test_memdup(:string, :pointer)
>>>>
>>>> $ ruby glib_memduptest.rb
>>>> [:buffer, :buffer_out, "a\000b\000c", "a\000b\000c", true]
>>>> [:buffer, :pointer, "a\000b\000c", "a\000b\000c", true]
>>>> [:string, :buffer_out, "a\000b\000c", "a\000b\000c", true]
>>>> [:string, :pointer, "a\000b\000c", "a\000b\000c", true]
>>>>
>>>> $ jruby glib_memduptest.rb
>>>> [:buffer, :buffer_out, "a\000b\000c", "\300\370\177\260A", false]
>>>> [:buffer, :pointer, "a\000b\000c", "a\000b\000c", true]
>>>> [:string, :buffer_out, "\001\000\000\000\270", "\001\000\000\000\270",
>>>> true]
>>>> [:string, :pointer, "\001\000\000\000\270", "\001\000\000\000\270",
>>>> true]
>>>>
>>>> I'm not really sure what's happening in the jruby case. If I use an
>>>> explicit FFI::Buffer with :pointer, it seems to work.
>>>>
>>>> What's really strange though, is that if you reverse the order in
>>>> which the tests happen (so the string versions execute first), they
>>>> all fail:
>>>>
>>>> GLib.test_memdup(:string, :buffer_out)
>>>> GLib.test_memdup(:string, :pointer)
>>>> GLib.test_memdup(:buffer, :buffer_out)
>>>> GLib.test_memdup(:buffer, :pointer)
>>>>
>>>> $ jruby glib_memduptest.rb
>>>> [:string, :buffer_out, "\300\370\177\260A", "\300\370\177\260A", true]
>>>> [:string, :pointer, "\300\370\177\260A", "\300\370\177\260A", true]
>>>> [:buffer, :buffer_out, "\300\370\177\260A", "0\f\200\001@", false]
>>>> [:buffer, :pointer, "\300\370\177\260A", "\300\370\177\260A", true]
>>>>
>>>
>>
>
