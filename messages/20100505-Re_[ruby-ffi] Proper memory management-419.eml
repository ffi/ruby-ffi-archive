Delivered-To: headius@headius.com
Received: by 10.150.226.5 with SMTP id y5cs11138ybg;
        Wed, 5 May 2010 18:29:52 -0700 (PDT)
Received: by 10.150.120.33 with SMTP id s33mr581201ybc.50.1273109392122;
        Wed, 05 May 2010 18:29:52 -0700 (PDT)
Return-Path: <ruby-ffi+bncCMPYuayYERCMt4jfBBoEwRHpPw@googlegroups.com>
Received: from mail-gx0-f189.google.com (mail-gx0-f189.google.com [209.85.217.189])
        by mx.google.com with ESMTP id 37si927279yxe.55.2010.05.05.18.29.51;
        Wed, 05 May 2010 18:29:51 -0700 (PDT)
Received-SPF: pass (google.com: domain of ruby-ffi+bncCMPYuayYERCMt4jfBBoEwRHpPw@googlegroups.com designates 209.85.217.189 as permitted sender) client-ip=209.85.217.189;
Authentication-Results: mx.google.com; spf=pass (google.com: domain of ruby-ffi+bncCMPYuayYERCMt4jfBBoEwRHpPw@googlegroups.com designates 209.85.217.189 as permitted sender) smtp.mail=ruby-ffi+bncCMPYuayYERCMt4jfBBoEwRHpPw@googlegroups.com; dkim=pass (test mode) header.i=@googlegroups.com
Received: by gxk5 with SMTP id 5sf3405405gxk.14
        for <headius@headius.com>; Wed, 05 May 2010 18:29:50 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=googlegroups.com; s=beta;
        h=domainkey-signature:received:x-beenthere:received:received:received
         :received:received:received-spf:received:mime-version:received
         :received:in-reply-to:references:date:message-id:subject:from:to
         :x-original-authentication-results:x-original-sender:reply-to
         :precedence:mailing-list:list-id:list-post:list-help:list-archive
         :sender:list-subscribe:list-unsubscribe:content-type;
        bh=8FWmBiSazi8mU2IAOlW4B7oTBHpQTzlksb++phpQ3wg=;
        b=s0S291zMxBhKm3KT2GdhUtfBsdn2ucHPuk8Nd6R4s+HgrxH7i2HkT0pB51ELe55BrQ
         6WqfDiw8h8kAsM00TWfCV3cHmZWSPa6mkX0oTUYo+uGIxDd0yD0z0gr4iHQ778wPU9gB
         KtEMvIOmnLNHQEn0MtVXTw3fOYkOvHaVuSvaE=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=googlegroups.com; s=beta;
        h=x-beenthere:received-spf:mime-version:in-reply-to:references:date
         :message-id:subject:from:to:x-original-authentication-results
         :x-original-sender:reply-to:precedence:mailing-list:list-id
         :list-post:list-help:list-archive:sender:list-subscribe
         :list-unsubscribe:content-type;
        b=FTF8ulTCKVa6/43SsRGDy9ExXZVO0MSYHSbAdKoyYrsvjGQrqodL9Vtg7ee+nTKrjD
         4EkylesXDAMZ2jlwXSEIFrm4hIhqPTKV1DqIom/TRie55dFU4Qo6kyd0zBYw9YltBclw
         /mPetKzSn/UdT0Ne8KUYcko2xj44a6jklBYSQ=
Received: by 10.150.247.2 with SMTP id u2mr20394ybh.23.1273109388786;
        Wed, 05 May 2010 18:29:48 -0700 (PDT)
X-BeenThere: ruby-ffi@googlegroups.com
Received: by 10.150.234.22 with SMTP id g22ls4536258ybh.7.p; Wed, 05 May 2010 
	18:29:48 -0700 (PDT)
Received: by 10.150.132.17 with SMTP id f17mr312008ybd.9.1273109388025;
        Wed, 05 May 2010 18:29:48 -0700 (PDT)
Received: by 10.140.83.22 with SMTP id g22mr26822rvb.4.1273107767384;
        Wed, 05 May 2010 18:02:47 -0700 (PDT)
Received: by 10.140.83.22 with SMTP id g22mr26821rvb.4.1273107767355;
        Wed, 05 May 2010 18:02:47 -0700 (PDT)
Return-Path: <jvoorhis@gmail.com>
Received: from mail-pw0-f41.google.com (mail-pw0-f41.google.com [209.85.160.41])
        by gmr-mx.google.com with ESMTP id 18si77021pzk.14.2010.05.05.18.02.46;
        Wed, 05 May 2010 18:02:46 -0700 (PDT)
Received-SPF: pass (google.com: domain of jvoorhis@gmail.com designates 209.85.160.41 as permitted sender) client-ip=209.85.160.41;
Received: by pwi10 with SMTP id 10so2559357pwi.14
        for <ruby-ffi@googlegroups.com>; Wed, 05 May 2010 18:02:46 -0700 (PDT)
MIME-Version: 1.0
Received: by 10.142.66.11 with SMTP id o11mr1704580wfa.121.1273107766216; Wed, 
	05 May 2010 18:02:46 -0700 (PDT)
Received: by 10.142.225.2 with HTTP; Wed, 5 May 2010 18:02:46 -0700 (PDT)
In-Reply-To: <499b1ee0-00c4-4113-9b2e-70f50019d619@e2g2000yqn.googlegroups.com>
References: <499b1ee0-00c4-4113-9b2e-70f50019d619@e2g2000yqn.googlegroups.com>
Date: Wed, 5 May 2010 18:02:46 -0700
Message-ID: <u2q94e476fd1005051802k61f2fd19r56e57ddfd75b5e98@mail.gmail.com>
Subject: Re: [ruby-ffi] Proper memory management
From: Jeremy Voorhis <jvoorhis@gmail.com>
To: ruby-ffi@googlegroups.com
X-Original-Authentication-Results: gmr-mx.google.com; spf=pass (google.com: 
	domain of jvoorhis@gmail.com designates 209.85.160.41 as permitted sender) 
	smtp.mail=jvoorhis@gmail.com; dkim=pass (test mode) header.i=@gmail.com
X-Original-Sender: jvoorhis@gmail.com
Reply-To: ruby-ffi@googlegroups.com
Precedence: list
Mailing-list: list ruby-ffi@googlegroups.com; contact ruby-ffi+owners@googlegroups.com
List-ID: <ruby-ffi.googlegroups.com>
List-Post: <http://groups.google.com/group/ruby-ffi/post?hl=en_US>, 
	<mailto:ruby-ffi@googlegroups.com>
List-Help: <http://groups.google.com/support/?hl=en_US>, <mailto:ruby-ffi+help@googlegroups.com>
List-Archive: <http://groups.google.com/group/ruby-ffi?hl=en_US>
Sender: ruby-ffi@googlegroups.com
List-Subscribe: <http://groups.google.com/group/ruby-ffi/subscribe?hl=en_US>, 
	<mailto:ruby-ffi+subscribe@googlegroups.com>
List-Unsubscribe: <http://groups.google.com/group/ruby-ffi/subscribe?hl=en_US>, 
	<mailto:ruby-ffi+unsubscribe@googlegroups.com>
Content-Type: multipart/alternative; boundary=001636e0b9b82a88120485e280f2

--001636e0b9b82a88120485e280f2
Content-Type: text/plain; charset=UTF-8

I know from discussions over irc that Evan Phoenix isn't too keen on using
finalizers for memory management for this very reason. In my own projects,
I've found myself occasionally writing #dispose methods for manual object
deletion, along with a block form of the constructor that ensures #dispose
is called after the block is run. If controlling when memory should be freed
is important, it's probably best not to rely on MRI's GC!

Best

Jeremy

On Wed, May 5, 2010 at 3:56 PM, v01d <phreakuencies@gmail.com> wrote:

> Hi,
> I'm in the process of developing a Ruby binding to the GSL numerical
> library using FFI. Recently I stumbled upon a problematic issue
> regarding memory management and finalizers.
>
> Since the GSL library allows creation and destruction of instances
> like this:
> gsl_vector* ptr = gsl_alloc_vector(size_t n);
> ...
> gsl_free_vector(ptr);
>
> Then, in Ruby I do something like this:
>
> class Vector
>  def initialize(n)
>    @ptr = GSLng.backend.gsl_alloc_vector(n)
>    Vector.define_finalizer(self, @ptr)
>  end
>
>  def Vector.define_finalizer(self, ptr)
>    ObjectSpace.define_finalizer(self, lambda {|id|
> GSLng.backend.gsl_free_vector(ptr)})
>  end
> end
>
> The problem is that if later I instatiante a Vector inside a loop,
> like:
> 10000.times do
>  Vector.new(3)
> end
>
> This obviously eats a lot of memory until GC runs. Now, if I do:
> 10000.times do
>  Vector.new(3)
>  GC.start
> end
>
> the memory that the Vector instances themselves occupy is freed but
> the finalizer is not called (it is later called at program end),
> therefore all of the memory allocated through gsl_alloc_vector() is
> sitting there until program ends.
>
> I know that Ruby doesn't guarantee that finalizers are called in any
> particular moment (even after GC.start, which I thought would
> suffice). So what I'm asking probably is not really related to FFI
> itself, but I wanted to ask here since I imagined this would be a
> common pattern among FFI users. The question is then: is there a
> better way to manage this type of memory? I obviously cant use the
> transaction-like pattern (like File.open) since for a Vector that
> wouldn't make sense. It would be ideal to make the gsl_vector_free
> call when the actual Vector class is free'd. Maybe I need to go to a
> lower level for this and use the C api to register this call in the
> "free" function for this class, but that would be overkill since I
> wanted to avoid using C altogether.
>
> Thank you!
>

--001636e0b9b82a88120485e280f2
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

I know from discussions over irc that Evan Phoenix isn&#39;t too keen on us=
ing finalizers for memory management for this very reason. In my own projec=
ts, I&#39;ve found myself occasionally writing #dispose methods for manual =
object deletion, along with a block form of the constructor that ensures #d=
ispose is called after the block is run. If controlling when memory should =
be freed is important, it&#39;s probably best not to rely on MRI&#39;s GC!<=
div>
<br></div><div>Best</div><div><br></div><div>Jeremy<br><br><div class=3D"gm=
ail_quote">On Wed, May 5, 2010 at 3:56 PM, v01d <span dir=3D"ltr">&lt;<a hr=
ef=3D"mailto:phreakuencies@gmail.com">phreakuencies@gmail.com</a>&gt;</span=
> wrote:<br>
<blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;border-left:1p=
x #ccc solid;padding-left:1ex;">Hi,<br>
I&#39;m in the process of developing a Ruby binding to the GSL numerical<br=
>
library using FFI. Recently I stumbled upon a problematic issue<br>
regarding memory management and finalizers.<br>
<br>
Since the GSL library allows creation and destruction of instances<br>
like this:<br>
gsl_vector* ptr =3D gsl_alloc_vector(size_t n);<br>
...<br>
gsl_free_vector(ptr);<br>
<br>
Then, in Ruby I do something like this:<br>
<br>
class Vector<br>
 =C2=A0def initialize(n)<br>
 =C2=A0 =C2=A0@ptr =3D GSLng.backend.gsl_alloc_vector(n)<br>
 =C2=A0 =C2=A0Vector.define_finalizer(self, @ptr)<br>
 =C2=A0end<br>
<br>
 =C2=A0def Vector.define_finalizer(self, ptr)<br>
 =C2=A0 =C2=A0ObjectSpace.define_finalizer(self, lambda {|id|<br>
GSLng.backend.gsl_free_vector(ptr)})<br>
 =C2=A0end<br>
end<br>
<br>
The problem is that if later I instatiante a Vector inside a loop,<br>
like:<br>
10000.times do<br>
 =C2=A0Vector.new(3)<br>
end<br>
<br>
This obviously eats a lot of memory until GC runs. Now, if I do:<br>
10000.times do<br>
 =C2=A0Vector.new(3)<br>
 =C2=A0GC.start<br>
end<br>
<br>
the memory that the Vector instances themselves occupy is freed but<br>
the finalizer is not called (it is later called at program end),<br>
therefore all of the memory allocated through gsl_alloc_vector() is<br>
sitting there until program ends.<br>
<br>
I know that Ruby doesn&#39;t guarantee that finalizers are called in any<br=
>
particular moment (even after GC.start, which I thought would<br>
suffice). So what I&#39;m asking probably is not really related to FFI<br>
itself, but I wanted to ask here since I imagined this would be a<br>
common pattern among FFI users. The question is then: is there a<br>
better way to manage this type of memory? I obviously cant use the<br>
transaction-like pattern (like File.open) since for a Vector that<br>
wouldn&#39;t make sense. It would be ideal to make the gsl_vector_free<br>
call when the actual Vector class is free&#39;d. Maybe I need to go to a<br=
>
lower level for this and use the C api to register this call in the<br>
&quot;free&quot; function for this class, but that would be overkill since =
I<br>
wanted to avoid using C altogether.<br>
<br>
Thank you!<br>
</blockquote></div><br></div>

--001636e0b9b82a88120485e280f2--
